---
import { getCollectionCTM } from "@/lib/contentParser.astro";
import { slugifyyy } from "@/lib/utils/textConverter";
import { getLocaleUrlCTM } from "./utils/i18nUtils.ts";

// get all taxonomies from frontmatter
export const getTaxonomy = async (
  collection: any,
  name: string,
  lang: string,
) => {
  const singlePages = await getCollectionCTM(collection, lang);

  const uniqueTaxonomies = new Map<string, { name: string; slug: string }>();

  singlePages.forEach((page: any) => {
    let taxonomyPages = page.data[name] || [];
    if (import.meta.env.PROD) {
      taxonomyPages =
        !page.data.draft && !page.data.excludeFromSitemap
          ? page.data[name] || []
          : [];
    }

    taxonomyPages = [...taxonomyPages];
    taxonomyPages.forEach((category: string) => {
      if (category) {
        // Generate a URL-friendly slug. For non-Latin languages (e.g. Chinese),
        // slugify can return an empty string, which previously caused the
        // category list to be empty in those locales.
        let slug = slugifyyy(category);

        // Fallback: if slugify returns an empty string, fall back to a
        // whitespace-normalized version of the original text. Browsers
        // handle nonâ€‘ASCII path segments correctly and this keeps category
        // filtering working in all languages.
        if (!slug) {
          slug = category.trim().replace(/\s+/g, "-");
        }

        uniqueTaxonomies.set(category, { name: category, slug });
      }
    });
  });

  return Array.from(uniqueTaxonomies.values());
};

export const generateCategorySlugs = (
  categories: string[],
  lang: string,
  blogFolder: string,
) => {
  return categories.map((category) => {
    const slug = getLocaleUrlCTM(
      slugifyyy(category),
      lang,
      `/${blogFolder}/category`,
    );

    return {
      name: category,
      slug: slug,
    };
  });
};
---
