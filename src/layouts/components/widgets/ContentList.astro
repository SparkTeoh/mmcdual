---
import { getCollectionCTM } from "@/lib/contentParser.astro";
import type { ContentListType } from "@/types";
import config from ".astro/config.generated.json" assert { type: "json" };
import BlogCard from "@/components/cards/BlogCard.astro";
import PortfolioCard from "@/components/cards/PortfolioCard.astro";
import { recursiveCloneObject } from "@/lib/utils/objectFunctions";
import Pagination from "@/components/widgets/Pagination.astro";
import { sortByDate } from "@/lib/utils/sortFunctions";

type Props = {
  class?: string;
  hasSearch?: boolean;
  pagination?: {
    enable: boolean;
    currentPage: number;
  };
  filter?: {
    name: string;
    slug: string;
  }; // show filtered content list based on provided taxonomy
  options?: ContentListType;
  [key: string]: any;
};

const {
  class: className,
  pagination,
  filter,
  options,
  ...rest
} = Astro.props as Props;

const {
  content,
  layout,
  limit = false,
  gap = "gap-6",
  columns = 3,
} = options || {};

// Get content list based on content value
let list = [] as any[];

if (content === "portfolio") {
  list = await getCollectionCTM(
    config.settings.portfolioFolder as "case-studies",
    Astro.currentLocale,
  );
} else if (content === "blog") {
  list = await getCollectionCTM(
    config.settings.blogFolder as "blog",
    Astro.currentLocale,
  );
}

let posts = content === "blog" ? list : [];

// Filter content list based on category (If provided)
if (filter?.name) {
  list = list.filter((item) =>
    item.data.categories
      .map((cat: string) => cat.toLowerCase())
      .includes(filter?.name.toLocaleLowerCase()),
  );
}

// Limit content list
list =
  limit && list && pagination?.enable === false
    ? list.slice(0, limit as number)
    : list;

// Sort list by date
list = sortByDate(list);

// For Blog List Pagination
let totalPages = Math.ceil(posts?.length / config.settings.pagination);
if (content === "blog" && pagination?.enable) {
  const indexOfLastPost = pagination?.currentPage * config.settings.pagination;
  const indexOfFirstPost = indexOfLastPost - config.settings.pagination;
  list = posts.slice(indexOfFirstPost, indexOfLastPost);
}

if (list.length === 0) return;
---

<div
  class:list={[
    "blog-search-results",
    className,
    { "gap-6": gap === "gap-6" },
    { "gap-8": gap === "gap-8" },
    "gap-y-10",
    {
      "grid grid-cols-1": layout === "grid" && columns === 1,
      "grid md:grid-cols-2": layout === "grid" && columns === 2,
      "grid md:grid-cols-2 lg:grid-cols-3": layout === "grid" && columns === 3,
    },
    {
      "break-inside-avoid-column": layout === "masonry",
      "md:columns-1": layout === "masonry" && columns === 1,
      "md:columns-2": layout === "masonry" && columns === 2,
      "md:columns-2 lg:columns-3": layout === "masonry" && columns === 3,
    },
  ]}
  {...rest}>
  {
    list.map((item) =>
      content === "blog" ? (
        <BlogCard
          class:list={[
            {
              "mb-6": gap === "gap-6" && layout === "masonry",
              "mb-8": gap === "gap-8" && layout === "masonry",
            },
          ]}
          content={item}
          options={recursiveCloneObject(options)}
        />
      ) : content === "portfolio" ? (
        <PortfolioCard
          class:list={[
            {
              "mb-6": gap === "gap-6" && layout === "masonry",
              "mb-8": gap === "gap-8" && layout === "masonry",
              "break-inside-avoid-column": layout === "masonry",
            },
          ]}
          content={{ ...item.data, slug: item.id, ...item }}
          options={recursiveCloneObject(options)}
        />
      ) : null,
    )
  }
</div>
{
  content === "blog" && pagination?.enable && totalPages > 1 && (
    <div class="pt-8 text-center" id="pagination">
      <button
        id="load-more"
        class="btn btn-primary rounded-full px-8 py-3 text-white transition hover:bg-primary/90"
        data-current-page={pagination?.currentPage || 1}
        data-total-pages={totalPages}
      >
        Load More
      </button>
    </div>
  )
}

<script>
  const loadMoreBtn = document.getElementById("load-more") as HTMLButtonElement | null;
  const blogContainer = document.querySelector(".blog-search-results");

  if (loadMoreBtn && blogContainer) {
    loadMoreBtn.addEventListener("click", async () => {
      const currentPageAttr = loadMoreBtn.getAttribute("data-current-page");
      const totalPagesAttr = loadMoreBtn.getAttribute("data-total-pages");

      if (!currentPageAttr || !totalPagesAttr) return;

      const currentPage = parseInt(currentPageAttr);
      const totalPages = parseInt(totalPagesAttr);
      const nextPage = currentPage + 1;

      if (nextPage > totalPages) {
        loadMoreBtn.style.display = "none";
        return;
      }

      loadMoreBtn.textContent = "Loading...";
      loadMoreBtn.disabled = true;

      try {
        // Construct URL for the next page
        const currentPath = window.location.pathname.replace(/\/$/, "");
        
        let nextUrl = "";
        if (currentPath.includes("/page/")) {
          // Replace existing page number
          nextUrl = currentPath.replace(/\/page\/\d+/, `/page/${nextPage}`);
        } else {
          // Add page path
          nextUrl = `${currentPath}/page/${nextPage}`;
        }
        
        // Ensure trailing slash for consistency
        if (!nextUrl.endsWith("/")) {
          nextUrl += "/";
        }

        console.log("Loading more posts from:", nextUrl);

        const response = await fetch(nextUrl, {
          headers: {
            "Accept": "text/html",
          },
        });
        
        if (!response.ok) {
          throw new Error(`Failed to load more posts: ${response.status} ${response.statusText}`);
        }

        const text = await response.text();
        const parser = new DOMParser();
        const doc = parser.parseFromString(text, "text/html");
        
        // Try to find the blog container in the response
        const newPostsContainer = doc.querySelector(".blog-search-results");
        
        if (!newPostsContainer) {
          console.error("Could not find .blog-search-results in response");
          throw new Error("Invalid response structure");
        }

        const newPosts = newPostsContainer.querySelectorAll(":scope > *");

        if (newPosts.length === 0) {
          console.warn("No posts found in response");
          // Hide button if no more posts
          loadMoreBtn.style.display = "none";
          return;
        }

        // Clone and append each post
        newPosts.forEach((post) => {
          const clonedPost = post.cloneNode(true) as Element;
          blogContainer.appendChild(clonedPost);
        });

        loadMoreBtn.setAttribute("data-current-page", nextPage.toString());
        
        if (nextPage >= totalPages) {
          loadMoreBtn.style.display = "none";
        } else {
          loadMoreBtn.textContent = "Load More";
          loadMoreBtn.disabled = false;
        }
      } catch (error) {
        console.error("Load more error:", error);
        loadMoreBtn.textContent = "Error loading posts";
        loadMoreBtn.disabled = false;
        
        // Show error for a few seconds, then restore button
        setTimeout(() => {
          if (loadMoreBtn.textContent === "Error loading posts") {
            loadMoreBtn.textContent = "Load More";
          }
        }, 3000);
      }
    });
  }
</script>
